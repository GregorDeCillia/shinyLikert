{
    "contents" : "---\ntitle: \"Explorative Likert-scale Auswertung für Testfirma AG\"\nauthor: \"TU WIEN, Gregor de Cillia\"\ndate: \"01.11.2014\"\noutput:\n  html_document:\n    theme: cerulean\n    toc: no\nruntime: shiny\n---\n\n```{r User Inputs, echo = FALSE }\n\n# Optionen für Plot downloads\n{\n  downloadFormat  = \"jpg\"      # wähle zwischen png, jpeg, und bmp\n  download.width  = 800\n  download.height = 500\n}\n\n# Argumente für likert Plots\n{\n  as.percent     = TRUE       # zeige prozent oder personen in den plots?\n  positive.order = TRUE       # ordne die gruppen nach zustimmung oder alphabetisch?\n  axes.fontsize  = 16         # schriftgröße für achsenbeschriftungen\n  \n  tooltip.trigger = \"hover\"   # entweder \"hover\" oder \"click\". Bestimmt wann in\n                              # ggvis plots tootips erscheinen\n  }\n\n# Optionen für die Tests\n{\n  testAgainstAll = TRUE       # sollen die p-Werte durch \"teilgruppe gegen grundgesamtheit\"\n                              # berechnet werden? Die alternative ist \"teilgruppe gegen\n                              # komplementärgruppe\" (zB. Manager gegen nicht-Manager)\n    \n  criticalPValue = 0.05       # ab welchem wert werden p-werte in den Tablellen bold\n                              # angezeigt.\n  }\n\n```\n\n</br>\n\n____________\n\n\n<div style=\"width:250px;float: left;\">\n<a href=\"http://www.ooselo.ch\" target=\"_blank\">\n<img src=\"pictures/logo-ooselo.png\">\n</a>\n</div>\n<div style=\"width:300px;float: right;\">\n<a href=\"http://www.tuwien.ac.at/\" target=\"_blank\">\n<img src=\"pictures/logo-tu.png\" alt=\"Drawing\" style=\"width: 250px;\"/>\n</a>\n</div>\n\n</br></br></br></br>\n\n__________________\n\n# Einleitung\n\n```{r Importiere Dateien, echo = FALSE, results = 'hide', message = FALSE }\n\n# Lade nötige Pakete\n{\n  require( HH )                 # likert() befehl für plots \n  require( ggvis )              # interaktie plots (variablen chunk)\n  require( reshape2 )           # für decast: umwandlung von long in wideformat\n  require( coin )               # berechnung der p-werte\n  require( knitr )\n}\n\n# Importiere Daten\n{\n  dat = read.csv( \"testData.csv\", row.names = 1 )\n  attach( dat )                # macht die Spalten des data-frames direkt zugänglich.\n                               # Es lässt sich also dat$Frage direkt über Frage aufrufen\n}\n\n```\n\n```{r hardkodierte Größen, echo = FALSE}\n\nResponseLevel = c( \"Stimme gar nicht zu\", \n                   \"Stimme nicht zu\", \n                   \"Neutral\", \n                   \"Stimme zu\", \n                   \"Stimme stark zu\"\n                   )         # Im datensatz sind die entsprechenden Werte 1-5\nnamespossible = c( \"Funktion\",\n                   \"Unternehmen\",\n                   \"Land\",\n                   \"Stellung\",\n                   \"Abteilung\"\n                   )          # für faktoranalyse und variablen App. \n                              # Keine sensiblen Daten wie Name oder Email\n  \nescapeChar = \"`\"              # um in der `r ...` Umgebung den character ` in Strings\n                              # verwenden zu können ohne die Umgebung zu verlassen\n  \n```\n\n```{r utility funktionen, echo = FALSE }\n\nplotDownloadHandler = function( downloadName, inputLikertPlot ){  \n  downloadHandler(\n    filename = function() { \n      paste0( downloadName, '.', downloadFormat ) \n      },\n    content = function( file ) {\n      #downloadPlot( file )\n      switch( downloadFormat,\n              \"png\"  = png ( file, width = download.width, height = download.height ),\n              \"jpeg\" = jpeg( file, width = download.width, height = download.height ),\n              \"jpg\"  = jpeg( file, width = download.width, height = download.height ),\n              \"bmp\"  = bmp ( file, width = download.width, height = download.height )\n              )\n      plot( inputLikertPlot )\n      dev.off()\n      }\n    )\n  }\n\ntableDownloadHandler = function( downloadName, dataFrame ){\n  downloadHandler(\n    filename = function() {\n      paste0( downloadName, '.', \"csv\" )\n      },\n    content = function( file ) {\n      write.csv( dataFrame, file )  \n      }\n    )  \n  }\n\nboldPValue = function( pValueIndex ){\n  list( bPaginate = FALSE,\n        bFilter = FALSE,\n        fnRowCallback = I(\n          paste0(\n            'function( nRow, aData, iDisplayIndex, iDisplayIndexFull ) {                          \n              if ( parseFloat( aData[ ', pValueIndex, ' ] ) < ',\n                criticalPValue,\n                ')\n                $( \"td:eq( ', pValueIndex, ' )\", nRow ).css( \"font-weight\", \"bold\" );\n            }'\n            )\n          ),\n        bAutoWidth = FALSE\n        )\n  }\n\nplotLikert = function( formula, data, title, ylab.title , ... ){\n  likert( formula,\n          data = data,\n          main = title,\n          ylab = NULL,\n          as.percent = as.percent,\n          positive.order = positive.order,\n          strip = FALSE,\n          ylab.right = list( label = ylab.title, \n                             fontsize = axes.fontsize ),\n          xlab = list( label = \"Prozent\", \n                       fontsize = axes.fontsize ),\n          scales = list( cex = 1, \n                         y = list( relation = \"free\" ) \n                         ),\n          ...\n          \n    )  \n}\n\n```\n\nIn der vorliegenden HTML-Ausarbeitung handelt es sich um eine deskriptive Auswertung eines [likert-scale](https://en.wikipedia.org/wiki/Likert_scale) Datensatzes des Unternehmens [ooselo](http://www.ooselo.ch). Dieser Datensatz enstammt einer Befragung der Folgenden Form, welcher bei `r length(levels(Teilnehmername))` Personen durchgeführt wurde. \n\n___\n*Fragebogen mit zufälligen Personendaten*\n\n```{r Fragebogen, echo = FALSE}\n\n# Erzeuge Table mit Fragen eines Bereiches \ncreateQuestionTable = function( bereichInput ){\n  Fragen2 = unique( as.character( Frage )[ Bereich == bereichInput ] )\n  frame = data.frame( Fragen2, \"\", \"\", \"\", \"\", \"\" )\n  names( frame ) = c( \"Aussage\", ResponseLevel )\n  return( frame )\n  }\n\n# diese funktion erzeugt den Inhalt des Personendaten Reiters\nnonInteractiveSelectInput = function( Title, Value ){\n  HTML(\n    paste(\n      Title,\n      paste0( \"<div style=\\\"width:200px;height:20px; \n              -webkit-border-radius: 5px; \n              border:1px solid grey;\n              text-align: center;\\\">\",\n              Value,\n              \"</div>\"\n              ),\n      \"\",\n      sep = '<br/>' )\n    )\n  }\n\noutput$mytabs2 = renderUI({\n  # myTabs ... liste der bereichsTabs im Fagebogen \n  bereichsTabs = lapply(\n    levels( Bereich ),\n    function( str ){\n      tabPanel( str,\n                renderTable(\n                  createQuestionTable( str ),\n                  include.rownames = FALSE )\n                )\n      }\n    )\n  do.call(\n    tabsetPanel,\n    # do.call benötigt liste als zweites Argument. Die Elemente der Liste sind die Tabs\n    # betrachte str(bereichsTabs) für details.\n    append(   \n      list(\n        tabPanel(\n          \"Personendaten\",\n          fluidRow(\n            column( 6,\n                    nonInteractiveSelectInput( \"Name\",\n                                               \"Max Mustermann\" ),\n                    #textInput(\"a\",\"Name\",\"Max Mustermann\"),\n                    nonInteractiveSelectInput( \"Unternehmen\", \n                                               sample( Unternehmen, 1 ) ),\n                    #selectInput(\"b\",\"Unternehmen\",levels(Unternehmen),sample(Unternehmen,1)),\n                    nonInteractiveSelectInput( \"Stellung\",   \n                                               sample( Stellung, 1 ) )\n                    #selectInput(\"d\",\"Stellung\", levels(Stellung), sample((Stellung),1))\n                    ),\n            column( 6,\n                    nonInteractiveSelectInput( \"Funktion\",   \n                                               sample( Funktion, 1 ) ),\n                    #selectInput(\"c\",\"Funktion\",levels(Funktion),sample((Funktion),1)),\n                    nonInteractiveSelectInput( \"Abteilung\",  \n                                               sample( Abteilung, 1 ) ),\n                    #selectInput(\"e\",\"Abteilung\",levels(Abteilung),sample((Abteilung),1)),\n                    nonInteractiveSelectInput(\"Land\",       \n                                              sample( Land, 1 ) )\n                    #selectInput(\"f\",\"Land\",     levels(Land),     sample((Land),1))\n                    )\n            )\n          )\n        ), \n      bereichsTabs\n      )\n    ) # /do.call\n  \n  })\n\nuiOutput( 'mytabs2' )\n\n```\n\n________________________\n\nNun stellt sich die Frage, ob die Daten im \"Personendaten\" Reiter auf die likert-Variablen in den anderen Reitern einluss haben. Unsere Zielsetzung ist es, diese und ähnliche Fragen mit *explorativem Output* zu beantworten, d.h. den Datensatz anhand von *Grafiken* zu analysieren. Es wurden auch einfache *statistische Tests* ausgeführt, an Stellen, wo sie zu den Grafiken passen.\n\n## Über die Auswahl der Softwarepakete\n\nFür den Output wurden folgende [`R`](http://www.r-project.org/ \"R Homepage\")-pakete verwendet\n\n* [`HH`](http://www.jstatsoft.org/v57/i05 \"Paper über hier relevante Plots mit HH\"): Erzeugt für Plots für likert-scale Variablen. Besonders der Plotbefehl [`HH::likert`](http://www.inside-r.org/packages/cran/HH/docs/likert) ist sehr hilfeich zur grafischen Darstellung von Likert-Daten.\n* [`shiny`](http://shiny.rstudio.com/gallery/ \"Shiny Beispiele\"): Macht die Plots \"interaktiv\", ermöglicht also Nutzereingaben, die den Plot verändern.\n* [`ggvis`](https://github.com/rstudio/ggvis \"ggvis auf github\"): Erzeugt Plots die sich abhängig von der Mausposition verändern. In komination mit `shiny` lassen sich somit seht dynamische Grafiken erzeugen.\n* [`R-markdown`](https://support.rstudio.com/hc/en-us/articles/200552086-Using-R-Markdown \"Vorstellung der Funktionalität von Markdown anhand einfacher Beispiele\"): Erzeugt einen HTML-Output auf eine ähnliche weise wie [`sweave`](https://www.stat.uni-muenchen.de/~leisch/Sweave/) oder [`knitr`](http://yihui.name/knitr/).\n\n# Personendaten\n\nBevor wir uns mit dem Einfluss der Personendaten widmen, ein paar Worte zu diesen Daten selbst. Mit Ausnahme der Variable `Teilnehmername` sind alle Variablen aus dem Personendaten Reiter vom Typ `factor`, d.h. sie können zur *gruppierung* der Daten verwendet werden. Anschließen lassen sich *statistischen Methoden* anwenden. Beispielsweise können die Antworten von Österreichern ( `Antwort[ Land == \"A\" ]` ) denen von Schweizern ( `Antwort[ Land == \"CH\" ]` ) gegenübergestellt werden um zu sehen welche Nation positiver auf eine bestimmte Frage abgestimmt hat.\n\nDer Import der Daten erfolgt mittels `read.csv`\n\n```{r print import commands }\n\ndat = read.csv( \"testData.csv\", row.names = 1 )\nnames( dat )\n\n```\n\nDie Verteilung der unterschiedlichen `factor-levels` lässt sich durch folgende `shiny`-Applikation wiedergeben.\n\n________________________________________________\n\n```{r Verteilung der Factor-Levels, echo = FALSE, fig.width = 10, fig.height = 5}\n# Beschränke den Datensatz auf eine Frage\ndatFrage1 = dat[ Frage == levels( Frage )[ 1 ],  ]\n\n# selected_data: Verteilung der facor levels für die ausgewählten faktor\nselected_data = reactive({\n  if ( is.null( input$faktor ) ) \n    return( data.frame( x = Funktion ) )\n  else \n    return( data.frame( x = datFrage1[[ input$faktor ]] ) )\n  })\n\n# Erzeuge Tabs\noutput$faktorTabs = renderUI({\n  myTabs = lapply( namespossible, tabPanel )\n  do.call( tabsetPanel, \n           c( id = \"faktor\", myTabs ) \n           )\n  })\n\nuiOutput( 'faktorTabs' )\n\nplotGgvis = selected_data %>% \n  ggvis( x = ~x, width = \"1800px\" ) %>% \n  layer_bars( fill = \"sky blue\", \n              fillOpacity := 0.7,\n              fillOpacity.hover := 0.9 ) %>%\n  add_axis( \"y\", title = \"Personen\" ) %>%\n  add_axis( \"x\", title = \"\" ) %>%\n  add_tooltip( function( df ) {\n    if ( df$stack_upr_ > 1 )\n      paste0( df$stack_upr_, \" Personen\" )\n    else\n      paste0( df$stack_upr_, \" Person\" )\n    },\n    tooltip.trigger ) %>%\n  hide_legend( \"fill\" )\n\nplotGgvis\n\n```\n\n___\n\nMan sieht, dass beispielsweise im Faktor `Funktion` die Levels sehr unterschiedlich stark besetzt sind da die Anzahl der `Head of Switzerland` deutlich geringer ist als die Anzahl der `Prozessanwender`. \n\n# Fragenbereiche\n\nÜber die Nächste `Shiny`-Applikation wird ersichtlich in welchen Fragenbereichen die Antworten unterdurchschnittlich ausgefallen sind. Bei dem `Leistungsindex` handelt es sich um ein normiertes Rangmittel. Der `p-Wert` in der Tabelle berechnet sich durch den [Mann-Whitney U Test](http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U_test \"Kurze Beschreibung des Tests auf Wikipedia\") und sagt aus, ob der Leistunsindex einer Gruppe *signifikant* vom durschnittlichen `Leistungsindex` `r if (!testAgainstAll) \"der Komplementärgruppe\"` abweicht. Als *Signifikanzniveau* wird `r criticalPValue` verwendet. In der Tabelle werden sämtliche `p-Werte`, die kleiner als das *Signifinkanzniveau* sind **fett** dargestellt.\n\n__________\n\n\n```{r Gesamtübersicht (Fragenbereiche), echo = FALSE}\n\n# shinyApp() erzeugt ap in neuem Frame. Vorher definierte Größen, wie z.B. dat können\n# innerhalb der app verwendet werden\nshinyApp(\n  ui = tabsetPanel(\n    tabPanel( \"Leistungsindizes\",\n              fluidPage(\n                ggvisOutput( 'ggvis' )\n                )               \n              ),\n    tabPanel( \"Likert-Plot\",\n              plotOutput( \"likertPlot\", height = \"620px\" ),\n              downloadButton( 'downloadLikertPlot', \n                              paste0( 'Download als .', downloadFormat )\n                              )\n              ),\n    tabPanel( \"Tabelle\",\n              dataTableOutput( 'table' ),\n              downloadButton( 'downloadData', 'Download als .csv' )\n              )\n    ),\n  server = function( input, output, session ){\n    # erzeuge einen dataTable mit allen nötigen daten zum Plotten\n    dT = dcast( dat, \n                Bereich ~ Antwort, \n                fun.aggregate = length, \n                value.var = \"Kommentar\" )\n    dT = cbind( Faktor = \"Bereich\", dT )\n    dT = data.frame( rbind( c( \"\", \n                               \"Alle Antworten\", \n                               summary( Antwort ) \n                               ),\n                            as.matrix( dT )\n                            )\n                     )\n    for ( i in 3:7 )\n      dT[  , i ] = as.numeric( as.character( dT[  , i ] ) )  # urspünglich eine faktorvariable\n    dT = dT[  , c( 2 + order( order( ResponseLevel ) ), 2, 1 ) ]\n    names( dT ) = c( ResponseLevel, \"Bereich\", \"Faktor\" )\n    \n    pval = 1:length( levels( Bereich ) )\n    rankscale = pval\n    \n    subTable = dat[  , c( \"Bereich\", \"Antwort\" ) ]\n    subTable$Antwort = order( ResponseLevel )[ as.numeric( subTable$Antwort ) ]\n    r = rank( subTable$Antwort )\n    meanscale = mean( r )\n    \n    vec = rep( 0, length( levels( Bereich ) ) )\n    for ( i in 1:length( levels( Bereich ) ) ){\n      sub2 = subTable\n      vec[ i ] = 1\n      levels( sub2$Bereich ) = vec\n      if ( testAgainstAll ){         \n        sub3 = sub2[ sub2$Bereich == 1,  ]\n        sub3$Bereich = 0;\n        sub2 = rbind( sub2, sub3 )\n        }\n      pval[ i ] = pvalue( wilcox_test( Antwort ~ Bereich, data = sub2 ) )\n      \n      rankscale[ i ] = mean( r[ sub2$Bereich == 1 ] )\n      vec[ i ] = 0\n      }\n    \n    dT = cbind(\n      dT[],\n      list( \"p-Wert\" = c( 1, pval ) ),\n      list( Leistungsindex = ( c( meanscale, rankscale ) - 0.5 ) / length( r ) )\n      )\n    \n    tooltip.pvalue = function( x ) {\n      if ( is.null( x ) ) \n        return( NULL )\n      paste0( \"Leistungsindex:\", \n              round( x$stack_upr_, 6 ), \n              \"<br />\",\n              \"p-Wert: \", \n              round(\n                dT[ dT$Bereich == as.character( format( x[ 2 ] ) ), \"p-Wert\" ],\n                8 ) # verwende 8 nachlmmastellen\n              )\n      }\n    \n    add_title = function( vis, ..., title = \"Plot Title\" ) {\n      add_axis( vis,\n                \"x\", \n                orient = \"top\", \n                ticks = 0, \n                title = title,\n                properties = axis_props(\n                  axis = list( stroke = \"white\" ),\n                  labels = list( fontSize = 0 )\n                  ), \n                ...\n                )\n      }\n    \n    dT %>%\n      ggvis(\n        x = ~Bereich,\n        y = ~Leistungsindex,\n        stroke = ~Faktor ) %>%\n      layer_bars(\n        fill = \"sky blue\",\n        fillOpacity := 0.7,\n        fillOpacity.hover := 0.9 ) %>%\n      scale_numeric(\n        \"y\", \n        domain = range( dT$Leistungsindex ),\n        expand = 0.05,\n        clamp = TRUE, \n        zero = FALSE ) %>%\n      hide_legend( \"fill\" ) %>%\n      add_tooltip( tooltip.pvalue, tooltip.trigger ) %>%\n      add_axis( \"x\", \n                title = \"\",\n                properties = axis_props(\n                  labels = list(\n                    angle = 20,\n                    baseline = \"left\",\n                    align = \"left\"\n                    )\n                  )\n                ) %>%\n      add_title( title = \"Gesamtübersicht\" ) %>%\n      bind_shiny( \"ggvis\", \"ggvis_ui\" )\n    \n    likertPlot = plotLikert( Bereich ~ . | Faktor, \n                             dT[  , 1:7 ], \n                             \"Gesamtübersicht\", \n                             \"Fragen im Bereich\" , \n                             layout = c( 1, 2 ), \n                             strip.left = strip.custom( bg = \"gray85\" ),\n                             par.strip.text = list( cex = 1, lines = 5 )\n                             )\n    \n    output$likertPlot = renderPlot( likertPlot, height = 620 )\n    \n    output$table = renderDataTable(\n      dT,\n      options = boldPValue( 7 )\n      )\n    output$downloadData =\n      tableDownloadHandler( \"Gesamtübersicht\", dT )\n    output$downloadLikertPlot =\n      plotDownloadHandler( \"Gesamtübersicht-likertPlot\", likertPlot )\n    },\n  options = list( height = 730 )\n  )\n\n```\n\n________________\n\nWill man nun die am negativsten bewertete Frage innerhalb eines Fragenbereiches finden, ist folgende Anwendung hilfreich. Die `p-Werte` haben die selbe Aussagekraft wie in der letzten Anwendung - weicht der `Leistungsindex` einer gewissen frage *signifikant* vom *durchschnittlichen* `Leistungsindex` aller `r if ( !testAgainstAll ) \"anderen\"` Fragen ab.\n\n_________\n\n```{r zeige Fragen im Bereich, echo = FALSE}\n\n# shinyApp() erzeugt app in neuem Frame. Vorher definierte Größen, wie z.B. dat können\n# innerhalb der app verwendet werden\nshinyApp(\n  ui = fluidPage(\n    sliderInput( \"fragenLaenge\", \n                 \"Länge der Frage (Zeichen)\", \n                 min = 25, \n                 max = 100, \n                 value = 50\n                 ),\n    uiOutput( 'bereichTabs' ),\n    fluidPage(\n      tabsetPanel(\n        tabPanel( \"Plot\",\n                  plotOutput( 'bereichPlot', height = \"200%\" ),\n                  downloadButton( 'downloadBereichPlot', \n                                  paste0( 'Download als .', downloadFormat )\n                                  )\n                  ),\n        tabPanel( \"Tabelle\", \n                  dataTableOutput( 'bereichTable' ),\n                  downloadButton( 'downloadBereichTable', 'Downoad als .csv' )\n                  )\n        \n        )\n      )      \n    ),\n  server = function( input, output, session ){\n    \n    output$bereichTabs = renderUI({\n      myTabs = lapply( levels( Bereich ), tabPanel )\n      do.call( tabsetPanel, \n               c( id = \"fragenbereich\", myTabs ) \n               )\n      })\n    \n    bereichPlot = reactive({\n      subTable = dat[ Bereich == input$fragenbereich,  ]\n      # erzeuge datatable dT, dass alle nötigen daten für den likert-plot enthält\n      dT = dcast( subTable, \n                  Frage ~ Antwort, \n                  fun.aggregate = length, \n                  value.var = \"Kommentar\" \n                  )[  , c( 1, 1 + order( order( ResponseLevel ) ) ) ]\n      # Kürze die frage auf die gewünschte Länge\n      dT$Frage = substr( dT$Frage, 1, input$fragenLaenge )\n      \n      plotLikert( Frage ~ ., dT, input$fragenbereich, \"Anzahl der Antworten\" )\n      \n      })\n    \n    output$bereichPlot = renderPlot( bereichPlot(), height = 600 )\n    \n    output$downloadBereichPlot = \n      plotDownloadHandler( input$fragenbereich, bereichPlot() )\n    \n    bereichTable = reactive({\n      # erzeuge subtable der nur die daten aus dem ausgewählten fragenbereich enthält\n      if ( !is.null( input$fragenbereich ) ) {\n        subTable = dat[ Bereich == input$fragenbereich,  ]\n        }\n      else subTable = dat\n      bT = dcast( subTable,\n                  Frage ~ Antwort,\n                  fun.aggregate = length, \n                  value.var = \"Kommentar\" \n                  )\n      bT = cbind( Faktor = \"Frage\", bT )\n      bT = data.frame( rbind( c( \"\", \n                                 \" Alle Antworten im Bereich\", \n                                 summary( subTable$Antwort )\n                                 ), \n                              as.matrix( bT )\n                              )\n                       )\n      for ( i in 3:7 )\n        # HH::likert benötigt numerische inputs, keine levels\n        bT[  , i ] = as.numeric( as.character( bT[  , i ] ) )  \n      bT = bT[  , c( 2 + order( order( ResponseLevel ) ), 2, 1 ) ]\n      names( bT ) = c( ResponseLevel, \"Frage\", \"Faktor\" )\n      # verkeinere den subTable weiter, sodass nur mehr die testrelevanten Informationen\n      # übrig bleiben\n      subTable = subTable[  , c( \"Frage\", \"Antwort\" ) ]\n      subTable$Antwort = order( ResponseLevel )[ as.numeric( subTable$Antwort ) ]\n      subTable$Frage = as.factor( as.character( subTable$Frage ) )\n      r = rank( subTable$Antwort )  \n      pval = 1:length( levels( subTable$Frage ) )\n      rankscale = pval\n      meanscale = mean( r )   \n      vec = rep( 0, length( levels( subTable$Frage ) ) )\n      for ( i in 1:length( levels( subTable$Frage ) ) ){\n        sub2 = subTable\n        vec[ i ] = 1\n        levels( sub2$Frage ) = vec\n        vec[ i ] = 0\n        if ( testAgainstAll ){\n          sub3 = sub2[ sub2$Frage == 1,  ]\n          sub3$Frage = 0;\n          sub2 = rbind( sub2, sub3 )\n        }\n        pval[ i ] = pvalue( wilcox_test( Antwort ~ Frage, data = sub2 ) )\n        rankscale[ i ] = mean( r[ sub2$Frage == 1 ] )\n        #meanscale[ i ] = mean( r )\n        }\n      bT = cbind( bT[],\n                  list( \"p-Wert\" = c( 1, pval ) ),\n                  list( Leistungsindex = ( c( meanscale, rankscale ) - 0.5 )/length( r ) )\n                  )\n      return( bT )\n      })\n    \n    output$bereichTable = renderDataTable(\n      # Zeige die Faktor-Spalte (spalte 7) NICHT im tableoutput\n      bereichTable()[  , c( 1:6, 8, 9 ) ],\n      options = list(\n        aLengthMenu = 5,\n        iDisplayLength = 5, \n        # zeige alle kritischen p-Werte 'bold' an\n        fnRowCallback = I(\n          paste( 'function( nRow, aData, iDisplayIndex, iDisplayIndexFull ) {                          \n                 if ( parseFloat( aData[ 6 ] ) < ',\n                 criticalPValue,\n                 ')\n                 $( \"td:eq( 6 )\", nRow ).css( \"font-weight\", \"bold\" );\n                 }'\n                 )\n          ),\n        bAutoWidth = FALSE        \n        )\n      )\n    \n    output$downloadBereichTable =\n      tableDownloadHandler( input$fragenbereich, bereichTable() )\n    },\n  options = list( height = 1000 )\n  )\n\n```\n\n_________\n\n# Faktoranalyse\n\nMit der folgenden Aplikation ist es möglich, die Verteilung der Antworten auf einzelne Fragen genauer zu betrachten. \n\nDer `p-Wert` im `Tabelle` Reiter wurde mittels dem [Exakten Test nach Fischer](https://de.wikipedia.org/wiki/Exakter_Test_nach_Fisher) (`fisher.test`) berechnet. Es wird also getestet, ob gewisse Gruppen (zB. `Prozesseigner`) ein anderes *Antwortverhalten* haben als `r if (testAgainstAll) \"die Grungesamtheit\" else paste0( \"ihre *Komplementärgruppe* (nicht-\", escapeChar, \"Prozesseigner\", escapeChar, \")\" )`.\n\n__________\n\n\n```{r Faktoranalyse, echo = FALSE}\n\n# shinyApp() erzeugt ap in neuem Frame. Vorher definierte Größen, wie z.B. dat können\n# innerhalb der app verwendet werden\nshinyApp(\n  ui = fluidPage(\n    fluidRow(\n      column( 5,\n              uiOutput( 'BereichUI' )\n              ),\n      column( 7,\n              uiOutput( 'FrageUI' )\n              )    \n      ),\n    fluidRow(\n      checkboxGroupInput( 'faktoren', \n                          'Analysiere Abhängigkeit von:',\n                          namespossible, \n                          selected = namespossible[ c( 2, 5 ) ], \n                          inline = TRUE \n                          )\n      ),\n    fluidRow(\n      tabsetPanel( id = \"inTabset\",\n                   tabPanel(\n                     \"Plot\",\n                     plotOutput( \"likertPlot\", height = \"620px\" ),\n                     downloadButton( 'downloadLikertPlot', \n                                     paste0( 'download als .', downloadFormat ) \n                                     )\n                     ),\n                   tabPanel(\n                     \"Tabelle\",\n                     dataTableOutput( 'factorTable' ),\n                     downloadButton( 'downloadFactorTable', 'Download als .csv' )\n                     )\n                   )\n      )\n    ),\n  server = function( input, output, session ){\n    \n    faktorTable = function( inputFrage, inputFaktoren ){ \n      if ( is.null( inputFrage ) ) \n        inputFrage = levels( Frage )[ 1 ] \n      # Reduziere den Datensatz auf die relevanten Zeilen und Spalten.\n      dat2 = dat[ Frage == inputFrage, \n                  c( \"Teilnehmername\", \"Antwort\", inputFaktoren )\n                  ]\n      # erzeuge erste Reihe des faktorTables\n      fT = matrix( c( summary( dat2$Antwort ), \"Alle Antworten\", \"\" ),\n                   nrow = 1 )\n      # erzeuge die restlichen reihen\n      if ( !is.null( inputFaktoren ) )\n        for ( faktor in inputFaktoren ){\n          # just display occuring levels\n          dat2[  , faktor ] = as.factor( as.character( dat2[  , faktor ] ) ) \n          fT = rbind( fT,\n                      as.matrix(\n                        cbind(\n                          dcast( dat2,\n                                 dat2[  , faktor ] ~ Antwort,\n                                 value.var = faktor,\n                                 fun.aggregate = length,\n                                 drop = FALSE\n                                 )[  , c( 2:6, 1 ) ], \n                          faktor\n                          )\n                        )\n                      )\n          }             \n      # wandele die matrix fT in ein data.frame um, damit out als input \n      # für likert() geeinet ist\n      fT = data.frame( fT )\n      names( fT ) = c( ResponseLevel, \"Level\", \"Faktor\" )\n      for ( i in 1:5 )\n        fT[  , i ] = as.numeric( as.character( fT[  , i ] ) )  # starts as levels\n      n = nrow( fT )\n      p = 1:n\n      if ( !testAgainstAll )\n        for ( i in 1:n )  \n          p[ i ] = fisher.test( rbind( fT[ 1, 1:5 ] - fT[ i, 1:5 ], \n                                       fT[ i, 1:5 ] \n                                       ) \n                                )$p.value\n      if ( testAgainstAll ){\n        for (i in 1:n)  \n          p[ i ] = fisher.test( rbind( fT[1,1:5], \n                                       fT[ i, 1:5 ]) \n                                )$p.value\n        }\n      return( cbind( fT, \"p-Wert\" = p ) )\n      }\n    \n    ## reactive expressions\n    currentFT = reactive({ \n      faktorTable( input$frage, input$faktoren )\n      })\n    \n    main = reactive({\n      input$frage\n      })\n    \n    numberOfFactors = reactive({\n      length( input$faktoren )\n      })\n    \n    output$FrageUI = renderUI({\n      if ( !is.null( input$bereich ) ){\n        choicesNeu = unique( as.character( Frage[ Bereich == input$bereich ] ) )\n        selectInput( 'frage', 'Frage', choicesNeu, width = '200%' )\n        }\n      })\n    \n    output$BereichUI = renderUI({\n      selectInput( 'bereich', \n                   'Fragenbereich', \n                   levels( Bereich ),\n                   selected = input$fragenbereich,\n                   width = '200%'\n                   )\n      })\n    \n    likertPlotFactor = reactive({\n      plotLikert( Level ~ . | Faktor, currentFT()[  , 1:7 ], main(), \"Personen im Sektor\" , \n                  layout = c( 1, numberOfFactors() + 1 ), \n                  strip.left = strip.custom( bg = \"gray85\" ),\n                  par.strip.text = list( cex = 1, lines = 5 )\n                  )\n    })\n    \n    output$likertPlot = renderPlot({\n      likertPlotFactor()\n      }, height = 550 )\n    \n    output$downloadLikertPlot = \n      plotDownloadHandler( input$frage, likertPlotFactor() )\n    \n    output$factorTable = renderDataTable(\n      currentFT(),\n      options = boldPValue( 7 )\n      )\n    \n    output$downloadFactorTable = \n      tableDownloadHandler( input$frage, currentFT() )\n    \n    }, options = list( height = 1050 )\n  )\n\n```\n\n______________________\n\n",
    "created" : 1453110439614.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1842230617",
    "id" : "B7CDA0B8",
    "lastKnownWriteTime" : 1453180843,
    "path" : "C:/Users/grogon/workspace/ooselo-final/Main.Rmd",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "type" : "r_markdown"
}